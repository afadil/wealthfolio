use super::holdings_calculator::HoldingsCalculator;
use super::snapshot_repository::SnapshotRepository;
use crate::accounts::{Account, AccountRepositoryTrait};
use crate::activities::{Activity, ActivityRepositoryTrait};
use crate::constants::{DECIMAL_PRECISION, PORTFOLIO_TOTAL_ACCOUNT_ID};
use crate::errors::{CalculatorError, Error, Result};
use crate::fx::fx_traits::FxServiceTrait;
use crate::portfolio::snapshot::AccountStateSnapshot;
use crate::utils::time_utils::get_days_between;

use async_trait::async_trait;
use chrono::{NaiveDate, Utc};
use log::{debug, error, info, warn};
use rust_decimal::Decimal;
use std::collections::{BTreeMap, HashMap, HashSet};
use std::sync::{Arc, RwLock};

// --- Service Trait ---
#[async_trait]
pub trait SnapshotServiceTrait: Send + Sync {
    /// Calculates **holdings** snapshots incrementally for the given account IDs, starting from the last calculated date.
    /// If `account_ids` is `None`, calculates for all active accounts AND the "TOTAL" portfolio.
    /// If `account_ids` is `Some`, calculates only for the specified IDs. If "TOTAL" is included, it's calculated from all activities.
    /// If no snapshots exist, it performs a full calculation from the first activity.
    /// Snapshots generated by this method *only contain holdings information* (quantities, costs, cash).
    /// They do NOT contain valuation (market value, base currency conversions, daily gain).
    async fn calculate_holdings_snapshots(&self, account_ids: Option<&[String]>) -> Result<usize>;

    /// Forces a full recalculation of **holdings** snapshots for the given account IDs, deleting existing data first.
    /// If `account_ids` is `None`, recalculates for all active accounts AND the "TOTAL" portfolio.
    /// If `account_ids` is `Some`, recalculates only for the specified IDs. If "TOTAL" is included, it's calculated from all activities.
    /// Snapshots generated by this method *only contain holdings information*.
    async fn force_recalculate_holdings_snapshots(
        &self,
        account_ids: Option<&[String]>,
    ) -> Result<usize>;

    /// Retrieves calculated **holdings** keyframe snapshots for a specific account or the total portfolio within a date range.
    /// Does NOT reconstruct daily snapshots; returns only the saved keyframes.
    fn get_holdings_keyframes(
        &self,
        account_id: &str, // Use specific ID, "TOTAL" for portfolio total
        start_date: Option<NaiveDate>,
        end_date: Option<NaiveDate>,
    ) -> Result<Vec<AccountStateSnapshot>>;

    /// Retrieves **holdings** snapshots for a specific account or the total portfolio within a date range,
    /// reconstructing daily snapshots between saved keyframes by carrying forward holdings.
    /// Valuation fields in the returned snapshots will be zero or default.
    fn get_daily_holdings_snapshots(
        &self,
        account_id: &str, // Use specific ID, "TOTAL" for portfolio total
        start_date: Option<NaiveDate>,
        end_date: Option<NaiveDate>,
    ) -> Result<Vec<AccountStateSnapshot>>;

    /// Retrieves the most recent calculated **holdings** snapshot for a specific account.
    /// Valuation fields will be zero or default.
    fn get_latest_holdings_snapshot(&self, account_id: &str) -> Result<AccountStateSnapshot>;
}

// --- Service Implementation ---

#[derive(Clone)]
pub struct SnapshotService {
    base_currency: Arc<RwLock<String>>,
    account_repository: Arc<dyn AccountRepositoryTrait>,
    activity_repository: Arc<dyn ActivityRepositoryTrait>,
    snapshot_repository: Arc<SnapshotRepository>,
     holdings_calculator: HoldingsCalculator,
}

// Type aliases to simplify function signatures
type AccountsMap = HashMap<String, Account>; // Use HashMap for faster lookup
type ActivitiesVec = Vec<Activity>;
type ActivitiesByAccount = HashMap<String, BTreeMap<NaiveDate, Vec<Activity>>>;
type StartSnapshotsMap = HashMap<String, AccountStateSnapshot>;
type StartDatesMap = HashMap<String, NaiveDate>;

impl SnapshotService {
    pub fn new(
        base_currency: Arc<RwLock<String>>,
        account_repository: Arc<dyn AccountRepositoryTrait>,
        activity_repository: Arc<dyn ActivityRepositoryTrait>,
        snapshot_repository: Arc<SnapshotRepository>,
        fx_service: Arc<dyn FxServiceTrait>,
    ) -> Self {
        let holdings_calculator = HoldingsCalculator::new(fx_service.clone());
        Self {
            base_currency: base_currency.clone(),
            account_repository,
            activity_repository,
            snapshot_repository,
            holdings_calculator,
        }
    }

    // Create a virtual account object for TOTAL
    fn create_total_virtual_account(&self) -> Account {
        let now = Utc::now().naive_utc();
        Account {
            id: PORTFOLIO_TOTAL_ACCOUNT_ID.to_string(),
            name: "Total Portfolio".to_string(),
            currency: self.base_currency.read().unwrap().clone(),
            is_active: true,                       // Correct field name
            account_type: "AGGREGATE".to_string(), // Indicate it's a special type
            group: None,
            is_default: false,
            created_at: now,
            updated_at: now,
            platform_id: None,
        }
    }

    // --- Core Calculation Logic (Internal Helper) ---
    async fn calculate_holdings_snapshots_internal(
        &self,
        account_ids_param: Option<&[String]>,
        force_full_calculation: bool,
    ) -> Result<usize> {
        debug!(
            "Starting snapshot calculation (Holdings Only) for {:?} accounts. Force full: {}",
            account_ids_param, force_full_calculation
        );

        // Step 1-3: Fetch required data
        // `accounts_to_process` includes individual accounts AND the virtual TOTAL account if needed.
        // `all_activities` contains activities ONLY for the accounts being processed (individual or all if TOTAL).
        let (accounts_to_process, all_activities, min_activity_date, calculation_end_date) =
            self.fetch_required_data(account_ids_param)?;

        if accounts_to_process.is_empty() {
            warn!("No accounts found to process.");
            return Ok(0);
        }

        // If forcing full calc and no activities exist, still need to clear snapshots.
        if all_activities.is_empty() && force_full_calculation {
            warn!("No activities found. Clearing snapshots due to force_full_calculation.");
            let ids_to_delete: Vec<String> = accounts_to_process.keys().cloned().collect();
            if !ids_to_delete.is_empty() {
                self.snapshot_repository
                    .delete_snapshots_by_account_ids(&ids_to_delete)?;
            }
            return Ok(0);
        } else if all_activities.is_empty() {
            warn!("No activities found for accounts. Calculation will be trivial.");
            // No activities, nothing to calculate or save, even for TOTAL.
            return Ok(0);
        }

        // Step 5: Pre-process activities (adjust for splits, group by account/date)
        // Includes grouping all activities under "TOTAL" key if needed.
        let (activities_by_account_date, account_ids_with_activity) = self.preprocess_data(
            &accounts_to_process,
            &all_activities,
            min_activity_date,
            calculation_end_date,
        )?;

        // Step 6: Determine calculation range and initial state for each account (including TOTAL)
        let (start_keyframes, effective_start_dates, calculation_min_date) = self
            .determine_calculation_range_and_initial_state(
                &accounts_to_process,
                &activities_by_account_date,
                &account_ids_with_activity, // Pass accounts that actually have activity
                force_full_calculation,
                calculation_end_date,
            )?;

        // Filter accounts that actually need calculation based on effective_start_dates
        let accounts_needing_calculation: AccountsMap = accounts_to_process
            .iter()
            .filter(|(id, _)| effective_start_dates.contains_key(*id))
            .map(|(id, acc)| (id.clone(), acc.clone()))
            .collect();

        if accounts_needing_calculation.is_empty() {
            debug!("No accounts require snapshot calculation in the specified range.");
            return Ok(0);
        }

        // Step 7: Calculate daily snapshots (in memory), identify keyframes
        let (_final_holdings_states, keyframes_to_save) = self.calculate_daily_holdings_snapshots(
            &accounts_needing_calculation,
            &activities_by_account_date,
            &start_keyframes,
            &effective_start_dates,
            calculation_min_date,
            calculation_end_date,
        )?;

        // Step 8: Persist only the identified keyframe snapshots (individual and/or TOTAL)
        self.snapshot_repository.replace_all_snapshots(
            &keyframes_to_save, // Pass the whole slice
            force_full_calculation
        )?;

        // Return count of saved keyframes as an indicator of work done
        Ok(keyframes_to_save.len())
    }

    // --- Step 1-3: Fetch required data ---
    // Fetches accounts based on `account_ids_param`. If `account_ids_param` is None or contains "TOTAL",
    // fetches ALL active accounts and creates the virtual TOTAL account.
    // Fetches activities ONLY for the relevant accounts (specified or all).
    fn fetch_required_data(
        &self,
        account_ids_param: Option<&[String]>,
    ) -> Result<(AccountsMap, ActivitiesVec, NaiveDate, NaiveDate)> {
        let mut accounts_to_process: AccountsMap = HashMap::new();
        let account_ids_to_fetch_activities: Vec<String>;
        let calculate_total =
            account_ids_param.map_or(true, |ids| ids.iter().any(|id| *id == PORTFOLIO_TOTAL_ACCOUNT_ID));

        // --- 1. Fetch Accounts ---
        if calculate_total {
            // Need all active accounts for TOTAL calculation + the virtual TOTAL account
            let all_active_accounts = self.account_repository.list(Some(true), None)?;
            if all_active_accounts.is_empty() {
                warn!("Processing TOTAL requested, but no active accounts found.");
                // Still create the virtual TOTAL account, but expect no activities
            }
            // Use iterator chain to collect IDs and extend the map
            account_ids_to_fetch_activities = all_active_accounts
                .iter()
                .map(|acc| acc.id.clone())
                .collect();
            accounts_to_process.extend(
                all_active_accounts
                    .into_iter()
                    .map(|acc| (acc.id.clone(), acc)),
            );

            accounts_to_process.insert(
                PORTFOLIO_TOTAL_ACCOUNT_ID.to_string(),
                self.create_total_virtual_account(),
            );
            // Add specific accounts requested *in addition* to TOTAL if any are provided and not already fetched
            if let Some(ids) = account_ids_param {
                let additional_accounts: Vec<Account> = ids
                    .iter()
                    .filter(|id| **id != PORTFOLIO_TOTAL_ACCOUNT_ID && !accounts_to_process.contains_key(*id))
                    .filter_map(|id| self.account_repository.get_by_id(id).ok())
                    .filter(|acc| acc.is_active)
                    .collect();
                // Don't need to add to fetch_activities again, already fetching all.
                accounts_to_process.extend(
                    additional_accounts
                        .into_iter()
                        .map(|acc| (acc.id.clone(), acc)),
                );
            }
        } else {
            // Process only specified accounts (guaranteed not to include TOTAL here)
            if let Some(ids) = account_ids_param {
                let fetched_accounts: Vec<Account> = ids
                    .iter()
                    // .filter(|id| **id != PORTFOLIO_TOTAL_ACCOUNT_ID) // Filter already applied by calculate_total check
                    .filter_map(|id| self.account_repository.get_by_id(id).ok())
                    .filter(|acc| acc.is_active)
                    .collect();

                account_ids_to_fetch_activities =
                    fetched_accounts.iter().map(|acc| acc.id.clone()).collect();
                accounts_to_process.extend(
                    fetched_accounts
                        .into_iter()
                        .map(|acc| (acc.id.clone(), acc)),
                );
            } else {
                // Should not happen if calculate_total is false, but handle defensively
                warn!("fetch_required_data called with account_ids_param=None and calculate_total=false. No accounts to fetch.");
                return Ok((
                    HashMap::new(),
                    Vec::new(),
                    Utc::now().naive_utc().date(),
                    Utc::now().naive_utc().date(),
                ));
            }
        }

        if accounts_to_process.is_empty() {
            return Ok((
                HashMap::new(),
                Vec::new(),
                Utc::now().naive_utc().date(),
                Utc::now().naive_utc().date(),
            ));
        }

        // --- 2. Fetch Activities ---
        let all_activities = if !account_ids_to_fetch_activities.is_empty() {
            self.activity_repository
                .get_activities_by_account_ids(&account_ids_to_fetch_activities)?
        } else {
            Vec::new() // No activities if no accounts to fetch for
        };

        // --- 3. Determine Date Range ---
        let min_activity_date = all_activities
            .iter()
            .map(|a| a.activity_date.naive_utc().date())
            .min()
            .unwrap_or_else(|| Utc::now().naive_utc().date());
        let calculation_end_date = Utc::now().naive_utc().date();

        Ok((
            accounts_to_process,
            all_activities,
            min_activity_date,
            calculation_end_date,
        ))
    }

    // --- Step 5: Preprocess activities ---
    // Adjusts for splits and groups activities.
    // If "TOTAL" account exists in `accounts_to_process`, adds ALL activities to its key.
    fn preprocess_data(
        &self,
        accounts_to_process: &AccountsMap, // Includes virtual TOTAL if needed
        all_activities: &[Activity],
        min_activity_date: NaiveDate,
        calculation_end_date: NaiveDate,
    ) -> Result<(ActivitiesByAccount, HashSet<String>)> {
        // Perform split adjustments on the raw activity list
        let split_factors =
            self.calculate_split_factors(all_activities, min_activity_date, calculation_end_date);
        let adjusted_activities = self.adjust_activities_for_splits(all_activities, &split_factors);

        // Group adjusted activities by original account ID and date
        let mut activities_by_account_date: ActivitiesByAccount = HashMap::new();
        let mut account_ids_with_activity: HashSet<String> = HashSet::new();

        for activity in &adjusted_activities {
            activities_by_account_date
                .entry(activity.account_id.clone())
                .or_default()
                .entry(activity.activity_date.naive_utc().date())
                .or_default()
                .push(activity.clone());
            account_ids_with_activity.insert(activity.account_id.clone());
        }

        // If processing TOTAL (i.e., TOTAL account is present), aggregate all activities under the TOTAL key
        if accounts_to_process.contains_key(PORTFOLIO_TOTAL_ACCOUNT_ID) {
            let mut total_activities_by_date: BTreeMap<NaiveDate, Vec<Activity>> = BTreeMap::new();
            for activity in &adjusted_activities {
                // Use adjusted activities here
                total_activities_by_date
                    .entry(activity.activity_date.naive_utc().date())
                    .or_default()
                    .push(activity.clone());
            }
            if !total_activities_by_date.is_empty() {
                activities_by_account_date
                    .insert(PORTFOLIO_TOTAL_ACCOUNT_ID.to_string(), total_activities_by_date);
                // Mark TOTAL as having activity if any underlying account did
                if !account_ids_with_activity.is_empty() {
                    account_ids_with_activity.insert(PORTFOLIO_TOTAL_ACCOUNT_ID.to_string());
                }
            }
        }

        // Ensure all accounts being processed (even those with no activities) have an entry
        // This simplifies downstream logic that expects keys to exist.
        for acc_id in accounts_to_process.keys() {
            activities_by_account_date
                .entry(acc_id.clone())
                .or_default();
        }

        Ok((activities_by_account_date, account_ids_with_activity))
    }

    // --- Step 6: Determine calculation range and initial state (Keyframes) ---
    // Handles individual accounts and the TOTAL account distinctly.
    fn determine_calculation_range_and_initial_state(
        &self,
        accounts_to_process: &AccountsMap, // Includes virtual TOTAL if needed
        activities_by_account_date: &ActivitiesByAccount, // Includes TOTAL key if needed
        account_ids_with_activity: &HashSet<String>, // Accounts that actually have activities
        force_full_calculation: bool,
        calculation_end_date: NaiveDate,
    ) -> Result<(StartSnapshotsMap, StartDatesMap, NaiveDate)> {
        let mut start_keyframes = HashMap::new();
        let mut effective_start_dates = HashMap::new();
        let mut overall_min_calc_date = calculation_end_date; // Start assuming today, find earlier dates

        // --- Delete snapshots if forcing full calculation ---
        if force_full_calculation {
            // Use iterator chain
            let ids_to_delete: Vec<String> = accounts_to_process.keys().cloned().collect();
            if !ids_to_delete.is_empty() {
                info!(
                    "Force full calculation: Deleting existing snapshots for accounts: {:?}",
                    ids_to_delete
                );
                self.snapshot_repository
                    .delete_snapshots_by_account_ids(&ids_to_delete)?;
            }
        }

        // --- Determine start state for each account ---
        // Use iterator chain
        let account_ids_to_check: Vec<String> = accounts_to_process.keys().cloned().collect();
        let latest_keyframes = if force_full_calculation {
            HashMap::new() // Don't fetch if forcing full recalc
        } else {
            self.snapshot_repository
                .get_all_latest_snapshots(&account_ids_to_check)?
        };

        for (account_id, account) in accounts_to_process {
            let account_has_activity = account_ids_with_activity.contains(account_id);

            if force_full_calculation {
                // --- Full Calculation Start State ---
                // Find the first date with activity *for this specific account* (or TOTAL)
                let first_activity_date = activities_by_account_date
                    .get(account_id) // Use the map which has TOTAL key if needed
                    .and_then(|date_map| date_map.keys().next().cloned())
                    .unwrap_or(calculation_end_date); // Default if no activities for this account

                // If the account has no activity at all, don't calculate it unless it's TOTAL
                // (TOTAL might need calculation even with no activity if sub-accounts were forced)
                if !account_has_activity && account_id != PORTFOLIO_TOTAL_ACCOUNT_ID {
                    debug!(
                        "Account {} has no activities and full recalc forced. Skipping.",
                        account_id
                    );
                    continue;
                }

                let initial_snapshot_date = first_activity_date
                    .pred_opt()
                    .unwrap_or(first_activity_date);
                let initial_keyframe =
                    Self::create_initial_snapshot(account, initial_snapshot_date); // Use account object (real or virtual)
                start_keyframes.insert(account_id.clone(), initial_keyframe);
                effective_start_dates.insert(account_id.clone(), first_activity_date);
                overall_min_calc_date = overall_min_calc_date.min(first_activity_date);
                debug!(
                    "Account {} (Full Recalc): Start date {}, Initial snapshot date {}",
                    account_id, first_activity_date, initial_snapshot_date
                );
            } else {
                // --- Incremental Calculation Start State ---
                if let Some(latest_keyframe) = latest_keyframes.get(account_id) {
                    let next_day_to_calculate = latest_keyframe
                        .snapshot_date
                        .succ_opt()
                        .unwrap_or(latest_keyframe.snapshot_date);

                    if next_day_to_calculate <= calculation_end_date {
                        // Only calculate if there's potential work to do
                        effective_start_dates.insert(account_id.clone(), next_day_to_calculate);
                        start_keyframes.insert(account_id.clone(), latest_keyframe.clone());
                        overall_min_calc_date = overall_min_calc_date.min(next_day_to_calculate);
                        debug!(
                            "Account {} (Incr): Start date {} based on keyframe from {}",
                            account_id, next_day_to_calculate, latest_keyframe.snapshot_date
                        );
                    } else {
                        debug!(
                            "Account {} is already up-to-date (Keyframe {}). Skipping.",
                            account_id, latest_keyframe.snapshot_date
                        );
                        // No calculation needed
                    }
                } else {
                    // --- No existing keyframe found (treat as full calc for this account) ---
                    let first_activity_date = activities_by_account_date
                        .get(account_id)
                        .and_then(|date_map| date_map.keys().next().cloned())
                        .unwrap_or(calculation_end_date);

                    // Only calculate if there actually are activities for this account
                    if account_has_activity || account_id == PORTFOLIO_TOTAL_ACCOUNT_ID {
                        // Always process TOTAL if requested initially
                        let initial_snapshot_date = first_activity_date
                            .pred_opt()
                            .unwrap_or(first_activity_date);
                        let initial_keyframe =
                            Self::create_initial_snapshot(account, initial_snapshot_date);
                        start_keyframes.insert(account_id.clone(), initial_keyframe);
                        effective_start_dates.insert(account_id.clone(), first_activity_date);
                        overall_min_calc_date = overall_min_calc_date.min(first_activity_date);
                        debug!(
                            "Account {} (Incr - No Keyframe): Start date {}, Initial snapshot date {}",
                            account_id, first_activity_date, initial_snapshot_date
                        );
                    } else {
                        debug!(
                            "Account {} has no previous keyframe and no activities. Skipping.",
                            account_id
                        );
                    }
                }
            }
        }

        // Ensure calculation_min_date is not after calculation_end_date
        overall_min_calc_date = overall_min_calc_date.min(calculation_end_date);

        Ok((
            start_keyframes,
            effective_start_dates,
            overall_min_calc_date,
        ))
    }

    // --- Step 7: Calculate daily holdings snapshots (in memory) and identify keyframes ---
    // Iterates through dates and calculates holdings for each account needing processing (incl. TOTAL).
    fn calculate_daily_holdings_snapshots(
        &self,
        accounts_needing_calculation: &AccountsMap, // Actual accounts to process
        activities_by_account_date: &ActivitiesByAccount, // Includes TOTAL key if needed
        start_keyframes: &StartSnapshotsMap, // Initial states for accounts needing calculation
        effective_start_dates: &StartDatesMap, // Start dates for accounts needing calculation
        calculation_min_date: NaiveDate,
        calculation_end_date: NaiveDate,
    ) -> Result<(
        HashMap<String, AccountStateSnapshot>, // Final states
        Vec<AccountStateSnapshot>,             // Keyframes to save
    )> {

        let mut current_holdings_snapshots = start_keyframes.clone();
        let mut keyframes_to_save: Vec<AccountStateSnapshot> = Vec::new();
        let date_range = get_days_between(calculation_min_date, calculation_end_date);

        for current_date in date_range {
            // Process only accounts whose effective start date is today or earlier
            let accounts_to_process_today: Vec<_> = accounts_needing_calculation
                .iter()
                .filter(|(id, _)| {
                    effective_start_dates
                        .get(*id)
                        .map_or(false, |start_date| *start_date <= current_date)
                })
                .collect();

            if accounts_to_process_today.is_empty() {
                // This shouldn't happen if calculation_min_date was determined correctly, but handle defensively.
                debug!(
                    "No accounts to process for date {}. Skipping day.",
                    current_date
                );
                continue;
            }

            let mut next_day_holdings_snapshots =
                HashMap::with_capacity(accounts_to_process_today.len());
            let mut keyframes_today = Vec::new();

            for (account_id, _account) in accounts_to_process_today {
                let previous_holdings_snapshot = current_holdings_snapshots
                    .get(account_id)
                     .ok_or_else(|| {
                         error!("CRITICAL: Missing previous holdings snapshot for account {} in memory map for date {}", account_id, current_date);
                         Error::Calculation(CalculatorError::Calculation(format!(
                             "Missing previous holdings snapshot for account {} for date {}",
                             account_id, current_date
                         )))
                     })?;

                // Get activities for THIS specific account (or the aggregated TOTAL activities)
                let activities_today = activities_by_account_date
                    .get(account_id) // Fetches individual or TOTAL activities based on account_id
                    .and_then(|date_map| date_map.get(&current_date))
                    .cloned()
                    .unwrap_or_default();

                let is_first_day = effective_start_dates.get(account_id) == Some(&current_date);
                let has_activities = !activities_today.is_empty();

                let current_holdings_snapshot: AccountStateSnapshot; // Final state for today

                if !has_activities {
                    // No activities today, just carry forward the previous state
                    let mut carried_forward_state = previous_holdings_snapshot.clone();
                    carried_forward_state.snapshot_date = current_date;
                    carried_forward_state.id = format!("{}_{}", account_id, current_date.format("%Y-%m-%d"));
                    // Note: calculated_at remains the same as the previous snapshot
                    current_holdings_snapshot = carried_forward_state;
                    debug!(
                        "No activities for account {} on {}. Carrying forward state.",
                        account_id, current_date
                    );
                } else {
                    // Activities occurred, call the calculator
                    match self.holdings_calculator.calculate_next_holdings(
                        previous_holdings_snapshot,
                        &activities_today, // Pass the already fetched activities
                        current_date,
                    ) {
                        Ok(calculated_snapshot) => {
                            // Calculator provides the new state, including updated calculated_at
                            current_holdings_snapshot = calculated_snapshot;
                             debug!(
                                "Holdings calculated successfully for account {} on {}",
                                account_id, current_date
                            );
                        }
                        Err(e) => {
                            error!(
                                "Holdings calculation failed for account {} on {}: {}. Carrying forward previous state.",
                                account_id, current_date, e
                            );
                            // Carry forward the previous day's state on error
                            let mut errored_state = previous_holdings_snapshot.clone();
                            errored_state.snapshot_date = current_date; // Update date even if carried forward
                            errored_state.id = format!("{}_{}", account_id, current_date.format("%Y-%m-%d"));
                            // calculated_at remains the same as the previous snapshot
                            current_holdings_snapshot = errored_state;
                        }
                    }
                }

                // Decide if it's a keyframe based on the determined snapshot
                // A keyframe is needed on the first day of calculation or if activities happened.
                let is_keyframe = is_first_day || has_activities;

                if is_keyframe {
                    debug!(
                        "Keyframe identified for account {} on {} (Holdings Only) (First day: {}, Has activities: {})",
                        account_id, current_date, is_first_day, has_activities
                    );
                    // Create the keyframe based on the final state for today
                    let mut keyframe_snapshot = current_holdings_snapshot.clone();
                    // Ensure account_id and id are correctly set for the keyframe
                    keyframe_snapshot.account_id = account_id.clone();
                    keyframe_snapshot.id = format!("{}_{}", account_id, current_date.format("%Y-%m-%d"));
                    keyframes_today.push(keyframe_snapshot);
                }

                // Store the calculated/carried-forward snapshot for the next iteration's "previous" state
                next_day_holdings_snapshots.insert(account_id.to_string(), current_holdings_snapshot); // Use the final determined snapshot
            }

            // Update the main state map for the next day
            // Important: Only update states for accounts processed today.
            for (id, state) in next_day_holdings_snapshots {
                current_holdings_snapshots.insert(id, state);
            }
            keyframes_to_save.extend(keyframes_today);
        }

        // Return the final holdings states and the identified keyframes
        Ok((current_holdings_snapshots, keyframes_to_save))
    }


    // --- Step 9: (Removed) Calculate and save total portfolio keyframes ---
    // This logic is now integrated into the main calculation loop by treating TOTAL as a virtual account.
    // The functions `calculate_and_save_total_portfolio_holdings`, `aggregate_holdings_for_total`,
    // and `aggregate_holdings_for_total2` are no longer needed here for holdings calculation.

    // --- Helpers ---

    // create_initial_snapshot creates a snapshot with default values
    fn create_initial_snapshot(account: &Account, date: NaiveDate) -> AccountStateSnapshot {
        AccountStateSnapshot {
            id: format!("{}_{}", account.id, date.format("%Y-%m-%d")),
            account_id: account.id.clone(),
            snapshot_date: date,
            currency: account.currency.clone(), // Use account's currency (base for TOTAL)
            calculated_at: Utc::now().naive_utc(),
            ..Default::default()
        }
    }

    // (Helper function group_activities_by_account_and_date moved inside preprocess_data)

    fn calculate_split_factors(
        &self,
        activities: &[Activity],
        start_date: NaiveDate,
        end_date: NaiveDate,
    ) -> HashMap<String, Vec<(NaiveDate, Decimal)>> {
        use crate::activities::activities_constants::ACTIVITY_TYPE_SPLIT;
        let mut split_factors: HashMap<String, Vec<(NaiveDate, Decimal)>> = HashMap::new();
        for activity in activities.iter().filter(|a| {
            a.activity_type == ACTIVITY_TYPE_SPLIT
                && a.activity_date.naive_utc().date() >= start_date
                && a.activity_date.naive_utc().date() <= end_date
        }) {
            // Use activity.quantity directly, it's Decimal, not Option<Decimal>
            let split_ratio = activity.quantity;
            if split_ratio.is_sign_positive() && !split_ratio.is_zero() {
                split_factors
                    .entry(activity.asset_id.clone())
                    .or_default()
                    .push((activity.activity_date.naive_utc().date(), split_ratio));
            } else {
                warn!(
                    "Invalid split ratio {} for activity {}. Ignoring split.",
                    split_ratio, activity.id
                );
            }
            // Removed handling for Option here as activity.quantity is not Option
        }
        for splits in split_factors.values_mut() {
            splits.sort_by_key(|k| k.0);
        }
        split_factors
    }

    fn adjust_activities_for_splits(
        &self,
        activities: &[Activity],
        split_factors: &HashMap<String, Vec<(NaiveDate, Decimal)>>,
    ) -> Vec<Activity> {
        use crate::activities::activities_constants::ACTIVITY_TYPE_SPLIT;

        let mut adjusted_activities = Vec::with_capacity(activities.len());
        for activity in activities {
            let mut adj_activity = activity.clone();
            if let Some(splits) = split_factors.get(&activity.asset_id) {
                // Do not adjust the SPLIT activity itself, only others
                if adj_activity.activity_type != ACTIVITY_TYPE_SPLIT {
                    let mut cumulative_factor = Decimal::ONE;
                    // Apply splits that happened *after* the activity date
                    for (split_date, split_ratio) in splits.iter() {
                        // Iterate chronologically
                        if *split_date > adj_activity.activity_date.naive_utc().date() {
                            // Split happened after this activity, need to adjust past quantity/price
                            cumulative_factor *= split_ratio;
                        }
                    }

                    if cumulative_factor != Decimal::ONE {
                        debug!(
                            "Adjusting activity {} on {} for asset {} due to future splits. Factor: {}",
                            adj_activity.id, adj_activity.activity_date.naive_utc().date(), adj_activity.asset_id, cumulative_factor
                        );
                        // Adjust quantity
                        // Use correct field name 'quantity'
                        adj_activity.quantity =
                            (activity.quantity * cumulative_factor).round_dp(DECIMAL_PRECISION);

                        // Adjust unit price (inverse factor)
                        // Use correct field name 'unit_price'
                        if !activity.unit_price.is_zero() {
                            if !cumulative_factor.is_zero() {
                                // Avoid division by zero
                                // Use correct field name 'unit_price'
                                adj_activity.unit_price = (activity.unit_price / cumulative_factor)
                                    .round_dp(DECIMAL_PRECISION);
                            } else {
                                warn!("Cumulative split factor is zero for activity {}. Cannot adjust unit price.", adj_activity.id);
                                // Use correct field name 'unit_price'
                                adj_activity.unit_price = Decimal::ZERO; // Or handle as error?
                            }
                        }
                    }
                }
            }
            adjusted_activities.push(adj_activity);
        }
        adjusted_activities
    }
}

#[async_trait]
impl SnapshotServiceTrait for SnapshotService {
    async fn calculate_holdings_snapshots(&self, account_ids: Option<&[String]>) -> Result<usize> {
        self.calculate_holdings_snapshots_internal(account_ids, false)
            .await
    }

    async fn force_recalculate_holdings_snapshots(
        &self,
        account_ids: Option<&[String]>,
    ) -> Result<usize> {
        self.calculate_holdings_snapshots_internal(account_ids, true)
            .await
    }

    fn get_holdings_keyframes(
        &self,
        account_id: &str,
        start_date_opt: Option<NaiveDate>,
        end_date_opt: Option<NaiveDate>,
    ) -> Result<Vec<AccountStateSnapshot>> {
        debug!(
            "Getting saved holdings keyframes for {} from {:?} to {:?}",
            account_id, start_date_opt, end_date_opt
        );
        // Directly fetch from the repository without reconstruction
        self.snapshot_repository
            .get_snapshots_by_account(account_id, start_date_opt, end_date_opt)
    }

    fn get_daily_holdings_snapshots(
        &self,
        account_id: &str,
        start_date_opt: Option<NaiveDate>,
        end_date_opt: Option<NaiveDate>,
    ) -> Result<Vec<AccountStateSnapshot>> {
        debug!(
            "Reconstructing daily holdings snapshots for {} from {:?} to {:?}",
            account_id, start_date_opt, end_date_opt
        );
        let end_date = end_date_opt.unwrap_or_else(|| Utc::now().naive_utc().date());

        // Determine start date: Use provided, else earliest, else end_date
        let start_date = match start_date_opt {
            Some(date) => date,
            None => {
                match self
                    .snapshot_repository
                    .get_earliest_snapshot_date(account_id)
                {
                    Ok(Some(date)) => date,
                    _ => {
                        warn!("No earliest snapshot found for account {}. Using end date {} as start date.", account_id, end_date);
                        end_date // Default to end date if no earliest found
                    }
                }
            }
        };

        if start_date > end_date {
            warn!(
                "get_daily_holdings_snapshots: Start date {} is after end date {}. Returning empty.",
                start_date, end_date
            );
            return Ok(Vec::new());
        }

        // Get latest state strictly *before* the start date to initialize the loop
        let initial_state_result = self
            .snapshot_repository
            .get_latest_snapshot_before_date(account_id, start_date);

        let Some(mut current_state) = initial_state_result? else {
            // If no snapshot *before* start date, we cannot reliably reconstruct.
            // Removed the complex fallback trying get_earliest_snapshot.
            debug!("No snapshot found before start date {} for account {}. Cannot reconstruct history.", start_date, account_id);
            return Ok(Vec::new());
        };

        // Fetch keyframes within the actual range
        let keyframes_in_range = self.snapshot_repository.get_snapshots_by_account(
            account_id,
            Some(start_date), // Fetch keyframes from start_date...
            Some(end_date),   // ...to end_date inclusive
        )?;

        let keyframes_map: BTreeMap<NaiveDate, AccountStateSnapshot> = keyframes_in_range
            .into_iter()
            .map(|kf| (kf.snapshot_date, kf))
            .collect();

        let capacity = (end_date - start_date).num_days().try_into().unwrap_or(0) + 1;
        let mut reconstructed_snapshots = Vec::with_capacity(capacity);
        let date_range = get_days_between(start_date, end_date);

        for current_date in date_range {
            if let Some(saved_keyframe) = keyframes_map.get(&current_date) {
                // Use the saved keyframe for this date
                current_state = saved_keyframe.clone();
                reconstructed_snapshots.push(saved_keyframe.clone());
            } else {
                // Reconstruct by carrying forward the previous day's state
                let mut reconstructed = current_state.clone();
                reconstructed.snapshot_date = current_date;
                reconstructed.id = format!(
                    "{}_{}",
                    reconstructed.account_id,
                    current_date.format("%Y-%m-%d")
                );
                // Removed lines attempting to reset non-existent valuation fields
                reconstructed.calculated_at = Utc::now().naive_utc(); // Mark when it was reconstructed

                current_state = reconstructed.clone(); // Update state for the next day
                reconstructed_snapshots.push(reconstructed);
            }
        }

        Ok(reconstructed_snapshots)
    }

    fn get_latest_holdings_snapshot(&self, account_id: &str) -> Result<AccountStateSnapshot> {
        let today = Utc::now().naive_utc().date();
        // Fetch the latest snapshot ON or BEFORE today
        // Use get_latest_snapshot_before_date
        match self
            .snapshot_repository
            .get_latest_snapshot_before_date(account_id, today)?
        {
            Some(snapshot) => Ok(snapshot),
            None => {
                error!(
                    "No snapshot found for account {} on or before {}",
                    account_id, today
                );
                // Use Error::Repository instead of Error::NotFound
                Err(Error::Repository(format!(
                    "No holdings snapshot found for account {}",
                    account_id
                )))
            }
        }
    }
}
