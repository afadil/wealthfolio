use super::holdings_calculator::HoldingsCalculator;
use super::SnapshotRepositoryTrait;
use crate::accounts::{Account, AccountRepositoryTrait, TrackingMode};
use crate::activities::{
    Activity, ActivityCompiler, ActivityRepositoryTrait, DefaultActivityCompiler,
};
use crate::assets::AssetRepositoryTrait;
use crate::constants::{DECIMAL_PRECISION, PORTFOLIO_TOTAL_ACCOUNT_ID};
use crate::errors::{CalculatorError, Error, Result};
use crate::events::{DomainEvent, DomainEventSink, NoOpDomainEventSink};
use crate::fx::FxServiceTrait;
use crate::portfolio::performance::{classify_flow_for_scope, FlowType, PerformanceScope};
use crate::portfolio::snapshot::{
    AccountStateSnapshot, HoldingsCalculationWarning, Lot, Position, SnapshotSource,
};
use crate::utils::time_utils::{get_days_between, valuation_date_today};

use async_trait::async_trait;
use chrono::{Months, NaiveDate, Utc};
use log::{debug, error, info, warn};
use rust_decimal::Decimal;
use std::collections::{BTreeMap, HashMap, HashSet, VecDeque};
use std::sync::{Arc, RwLock};

// --- Service Trait ---
#[async_trait]
pub trait SnapshotServiceTrait: Send + Sync {
    /// Calculates **holdings** snapshots incrementally for the given account IDs, starting from the last calculated date.
    /// If `account_ids` is `None`, calculates for all active accounts AND the "TOTAL" portfolio.
    /// If `account_ids` is `Some`, calculates only for the specified IDs. If "TOTAL" is included, it's calculated from all activities.
    /// If no snapshots exist, it performs a full calculation from the first activity.
    /// Snapshots generated by this method *only contain holdings information* (quantities, costs, cash).
    /// They do NOT contain valuation (market value, base currency conversions, daily gain).
    async fn calculate_holdings_snapshots(&self, account_ids: Option<&[String]>) -> Result<usize>;

    /// Forces a full recalculation of **holdings** snapshots for the given account IDs, deleting existing data first.
    /// If `account_ids` is `None`, recalculates for all active accounts AND the "TOTAL" portfolio.
    /// If `account_ids` is `Some`, recalculates only for the specified IDs. If "TOTAL" is included, it's calculated from all activities.
    /// Snapshots generated by this method *only contain holdings information*.
    async fn force_recalculate_holdings_snapshots(
        &self,
        account_ids: Option<&[String]>,
    ) -> Result<usize>;

    /// Retrieves calculated **holdings** keyframe snapshots for a specific account or the total portfolio within a date range.
    /// Does NOT reconstruct daily snapshots; returns only the saved keyframes.
    fn get_holdings_keyframes(
        &self,
        account_id: &str, // Use specific ID, "TOTAL" for portfolio total
        start_date: Option<NaiveDate>,
        end_date: Option<NaiveDate>,
    ) -> Result<Vec<AccountStateSnapshot>>;

    /// Retrieves **holdings** snapshots for a specific account or the total portfolio within a date range,
    /// reconstructing daily snapshots between saved keyframes by carrying forward holdings.
    /// Valuation fields in the returned snapshots will be zero or default.
    fn get_daily_holdings_snapshots(
        &self,
        account_id: &str, // Use specific ID, "TOTAL" for portfolio total
        start_date: Option<NaiveDate>,
        end_date: Option<NaiveDate>,
    ) -> Result<Vec<AccountStateSnapshot>>;

    /// Retrieves the most recent calculated **holdings** snapshot for a specific account.
    /// Returns `Ok(None)` when no snapshot exists yet. Valuation fields will be zero or default.
    fn get_latest_holdings_snapshot(
        &self,
        account_id: &str,
    ) -> Result<Option<AccountStateSnapshot>>;

    /// Calculates and stores aggregated "TOTAL" portfolio snapshots based on individual account holdings.
    /// This should typically be run after `calculate_holdings_snapshots` has processed individual accounts.
    /// Uses incremental calculation: skips if TOTAL snapshots are already up-to-date with individual keyframes.
    /// Only calculates new snapshots for dates after the latest existing TOTAL snapshot.
    async fn calculate_total_portfolio_snapshots(&self) -> Result<usize>;

    /// Forces a full recalculation of "TOTAL" portfolio snapshots, deleting existing data first.
    /// Use this when you need to rebuild the entire TOTAL history from scratch.
    async fn force_recalculate_total_portfolio_snapshots(&self) -> Result<usize>;

    /// Saves a manual snapshot for the given account.
    /// - The snapshot's source is preserved from the input (e.g., ManualEntry or CsvImport).
    /// - If a snapshot exists for the same date, it is updated in place.
    /// - If the date is different from existing snapshots, a new snapshot is created.
    /// - Triggers valuation recalculation for the account after saving.
    async fn save_manual_snapshot(
        &self,
        account_id: &str,
        snapshot: AccountStateSnapshot,
    ) -> Result<()>;

    /// Updates the source field for all snapshots of an account.
    /// Used when switching tracking modes (e.g., from HOLDINGS to TRANSACTIONS).
    /// Returns the number of snapshots updated.
    async fn update_snapshots_source(&self, account_id: &str, new_source: &str) -> Result<usize>;

    /// Ensures HOLDINGS mode accounts have at least 2 snapshots for proper history.
    /// If only 1 non-calculated snapshot exists, creates a synthetic snapshot 3 months prior.
    /// This enables history charting, valuation engines, and provides an inception boundary.
    async fn ensure_holdings_history(&self, account_id: &str) -> Result<()>;
}

// --- Service Implementation ---

#[derive(Clone)]
pub struct SnapshotService {
    base_currency: Arc<RwLock<String>>,
    account_repository: Arc<dyn AccountRepositoryTrait>,
    activity_repository: Arc<dyn ActivityRepositoryTrait>,
    snapshot_repository: Arc<dyn SnapshotRepositoryTrait>,
    holdings_calculator: HoldingsCalculator,
    event_sink: Arc<dyn DomainEventSink>,
}

// Type aliases to simplify function signatures
type AccountsMap = HashMap<String, Account>; // Use HashMap for faster lookup
type ActivitiesVec = Vec<Activity>;
type ActivitiesByAccount = HashMap<String, BTreeMap<NaiveDate, Vec<Activity>>>;
type StartSnapshotsMap = HashMap<String, AccountStateSnapshot>;
type StartDatesMap = HashMap<String, NaiveDate>;

impl SnapshotService {
    pub fn new(
        base_currency: Arc<RwLock<String>>,
        account_repository: Arc<dyn AccountRepositoryTrait>,
        activity_repository: Arc<dyn ActivityRepositoryTrait>,
        snapshot_repository: Arc<dyn SnapshotRepositoryTrait>,
        asset_repository: Arc<dyn AssetRepositoryTrait>,
        fx_service: Arc<dyn FxServiceTrait>,
    ) -> Self {
        let holdings_calculator = HoldingsCalculator::new(
            fx_service.clone(),
            base_currency.clone(),
            asset_repository.clone(),
        );
        Self {
            base_currency: base_currency.clone(),
            account_repository,
            activity_repository,
            snapshot_repository,
            holdings_calculator,
            event_sink: Arc::new(NoOpDomainEventSink),
        }
    }

    /// Sets the domain event sink for emitting HoldingsChanged events.
    pub fn with_event_sink(mut self, event_sink: Arc<dyn DomainEventSink>) -> Self {
        self.event_sink = event_sink;
        self
    }

    /// Emits a HoldingsChanged event for the given accounts and assets.
    fn emit_holdings_changed(&self, account_ids: Vec<String>, asset_ids: Vec<String>) {
        if !account_ids.is_empty() {
            self.event_sink.emit(DomainEvent::HoldingsChanged {
                account_ids,
                asset_ids,
            });
        }
    }

    // Create a virtual account object for TOTAL
    fn create_total_virtual_account(&self) -> Account {
        let now = Utc::now().naive_utc();
        Account {
            id: PORTFOLIO_TOTAL_ACCOUNT_ID.to_string(),
            name: "Total Portfolio".to_string(),
            currency: self.base_currency.read().unwrap().clone(),
            is_active: true,                       // Correct field name
            account_type: "AGGREGATE".to_string(), // Indicate it's a special type
            group: None,
            is_default: false,
            created_at: now,
            updated_at: now,
            platform_id: None,
            account_number: None,
            meta: None,
            provider: None,
            provider_account_id: None,
            is_archived: false,
            tracking_mode: crate::accounts::TrackingMode::NotSet,
        }
    }

    // --- Core Calculation Logic (Internal Helper) ---
    async fn calculate_holdings_snapshots_internal(
        &self,
        account_ids_param: Option<&[String]>,
        force_full_calculation: bool,
    ) -> Result<usize> {
        debug!(
            "Starting snapshot calculation (Holdings Only) for {:?} accounts. Force full: {}",
            account_ids_param, force_full_calculation
        );

        let (accounts_to_process, all_activities, min_activity_date, calculation_end_date) =
            self.fetch_required_data(account_ids_param)?;

        if accounts_to_process.is_empty() {
            warn!("No accounts found to process.");
            return Ok(0);
        }

        if all_activities.is_empty() && force_full_calculation {
            warn!("No activities found. Clearing snapshots due to force_full_calculation.");
            let ids_to_delete: Vec<String> = accounts_to_process.keys().cloned().collect();
            if !ids_to_delete.is_empty() {
                // If forcing full calc for specific accounts with no activities,
                // we should ensure their snapshots are wiped.
                self.snapshot_repository
                    .delete_snapshots_by_account_ids(&ids_to_delete)
                    .await?;
            }
            return Ok(0);
        } else if all_activities.is_empty() {
            warn!("No activities found for accounts. Calculation will be trivial.");
            return Ok(0);
        }

        let (activities_by_account_date, account_ids_with_activity) = self.preprocess_data(
            &accounts_to_process,
            &all_activities,
            min_activity_date,
            calculation_end_date,
        )?;

        let (start_keyframes, effective_start_dates, calculation_min_date) = self
            .determine_calculation_range_and_initial_state(
                &accounts_to_process,
                &activities_by_account_date,
                &account_ids_with_activity,
                force_full_calculation,
                calculation_end_date,
            )
            .await?;

        let accounts_needing_calculation: AccountsMap = accounts_to_process
            .iter()
            .filter(|(id, _)| effective_start_dates.contains_key(*id))
            .map(|(id, acc)| (id.clone(), acc.clone()))
            .collect();

        if accounts_needing_calculation.is_empty() {
            debug!("No accounts require snapshot calculation in the specified range.");
            return Ok(0);
        }

        let (_final_holdings_states, keyframes_to_save, calculation_warnings) = self
            .calculate_daily_holdings_snapshots(
                &accounts_needing_calculation,
                &activities_by_account_date,
                &start_keyframes,
                &effective_start_dates,
                calculation_min_date,
                calculation_end_date,
            )?;

        // Log detailed warnings for any activities that couldn't be processed
        if !calculation_warnings.is_empty() {
            error!(
                "Holdings snapshot calculation completed with {} activity warning(s):",
                calculation_warnings.len()
            );
            for warning in &calculation_warnings {
                error!("  - {}", warning);
            }
        }

        // Step 8: Persist keyframe snapshots using the new clear method
        for acc_id in accounts_needing_calculation.keys() {
            let frames: Vec<_> = keyframes_to_save
                .iter()
                .filter(|kf| kf.account_id == *acc_id)
                .cloned()
                .collect();

            if force_full_calculation {
                // wipe whole account then insert
                self.snapshot_repository
                    .overwrite_all_snapshots_for_account(acc_id, &frames)
                    .await?;
            } else {
                let start = *effective_start_dates.get(acc_id).unwrap();
                self.snapshot_repository
                    .overwrite_snapshots_for_account_in_range(
                        acc_id,
                        start,
                        calculation_end_date,
                        &frames,
                    )
                    .await?;
            }
        }

        Ok(keyframes_to_save.len())
    }

    // --- Step 1-3: Fetch required data ---
    // Fetches accounts based on `account_ids_param`. If `account_ids_param` is None or contains "TOTAL",
    // fetches ALL active accounts and creates the virtual TOTAL account.
    // Fetches activities ONLY for the relevant accounts (specified or all).
    fn fetch_required_data(
        &self,
        account_ids_param: Option<&[String]>,
    ) -> Result<(AccountsMap, ActivitiesVec, NaiveDate, NaiveDate)> {
        // ── ❶ decide if the caller explicitly asked for the virtual TOTAL ─────────────
        let calculate_total = account_ids_param
            .map(|ids| ids.iter().any(|id| *id == PORTFOLIO_TOTAL_ACCOUNT_ID))
            .unwrap_or(false); // ← no more implicit TOTAL when param == None

        let mut accounts_to_process: AccountsMap = HashMap::new();
        let mut account_ids_to_fetch_activities: Vec<String> = Vec::new();

        // ── ❷ collect *individual* accounts ──────────────────────────────────────────
        // Only include TRANSACTIONS mode accounts for snapshot recalculation.
        // HOLDINGS mode accounts manage their snapshots via manual entry/CSV import.
        match account_ids_param {
            Some(ids) => {
                // When specific account_ids are provided, process them regardless of is_active status
                // (per spec: "process exactly ids even inactive/archived for per-account rebuild")
                for id in ids {
                    if id == PORTFOLIO_TOTAL_ACCOUNT_ID {
                        continue;
                    } // TOTAL is virtual
                    if let Ok(acc) = self.account_repository.get_by_id(id) {
                        // Skip HOLDINGS mode accounts - they don't participate in transaction-based recalculation
                        if acc.tracking_mode == TrackingMode::Holdings {
                            debug!(
                                "Skipping account {} for snapshot recalculation: HOLDINGS tracking mode",
                                acc.id
                            );
                            continue;
                        }
                        account_ids_to_fetch_activities.push(acc.id.clone());
                        accounts_to_process.insert(acc.id.clone(), acc);
                    }
                }
            }
            None => {
                for acc in self.account_repository.list(Some(true), None, None)? {
                    // Skip HOLDINGS mode accounts - they don't participate in transaction-based recalculation
                    if acc.tracking_mode == TrackingMode::Holdings {
                        debug!(
                            "Skipping account {} for snapshot recalculation: HOLDINGS tracking mode",
                            acc.id
                        );
                        continue;
                    }
                    account_ids_to_fetch_activities.push(acc.id.clone());
                    accounts_to_process.insert(acc.id.clone(), acc);
                }
            }
        }

        // ── ❸ add the virtual TOTAL *only* if explicitly requested ───────────────────
        if calculate_total {
            accounts_to_process.insert(
                PORTFOLIO_TOTAL_ACCOUNT_ID.to_string(),
                self.create_total_virtual_account(),
            );
        }

        // ── ❹ pull activities for the collected individual accounts ──────────────────
        let all_activities = if !account_ids_to_fetch_activities.is_empty() {
            self.activity_repository
                .get_activities_by_account_ids(&account_ids_to_fetch_activities)?
        } else {
            Vec::new()
        };

        // unchanged: compute min_activity_date & calculation_end_date …
        let min_activity_date = all_activities
            .iter()
            .map(|a| a.activity_date.naive_utc().date())
            .min()
            .unwrap_or_else(valuation_date_today);

        let calculation_end_date = valuation_date_today();

        Ok((
            accounts_to_process,
            all_activities,
            min_activity_date,
            calculation_end_date,
        ))
    }

    // --- Step 5: Preprocess activities ---
    // Compiles activities (expands DRIP, STAKING_REWARD, etc.), adjusts for splits, and groups.
    // If "TOTAL" account exists in `accounts_to_process`, adds ALL activities to its key.
    fn preprocess_data(
        &self,
        accounts_to_process: &AccountsMap, // Includes virtual TOTAL if needed
        all_activities: &[Activity],
        min_activity_date: NaiveDate,
        calculation_end_date: NaiveDate,
    ) -> Result<(ActivitiesByAccount, HashSet<String>)> {
        // First, compile activities to expand composite types (DRIP, STAKING_REWARD, DIVIDEND_IN_KIND)
        // into their constituent legs (e.g., INTEREST + BUY for staking rewards)
        let compiler = DefaultActivityCompiler::new();
        let compiled_activities = compiler.compile_all(all_activities)?;

        // Perform split adjustments on the compiled activity list
        let split_factors = self.calculate_split_factors(
            &compiled_activities,
            min_activity_date,
            calculation_end_date,
        );
        let adjusted_activities =
            self.adjust_activities_for_splits(&compiled_activities, &split_factors);

        // Group adjusted activities by original account ID and date
        let mut activities_by_account_date: ActivitiesByAccount = HashMap::new();
        let mut account_ids_with_activity: HashSet<String> = HashSet::new();

        for activity in &adjusted_activities {
            activities_by_account_date
                .entry(activity.account_id.clone())
                .or_default()
                .entry(activity.activity_date.naive_utc().date())
                .or_default()
                .push(activity.clone());
            account_ids_with_activity.insert(activity.account_id.clone());
        }

        // If processing TOTAL (i.e., TOTAL account is present), aggregate all activities under the TOTAL key
        if accounts_to_process.contains_key(PORTFOLIO_TOTAL_ACCOUNT_ID) {
            let mut total_activities_by_date: BTreeMap<NaiveDate, Vec<Activity>> = BTreeMap::new();
            for activity in &adjusted_activities {
                // Use adjusted activities here
                total_activities_by_date
                    .entry(activity.activity_date.naive_utc().date())
                    .or_default()
                    .push(activity.clone());
            }
            if !total_activities_by_date.is_empty() {
                activities_by_account_date.insert(
                    PORTFOLIO_TOTAL_ACCOUNT_ID.to_string(),
                    total_activities_by_date,
                );
                // Mark TOTAL as having activity if any underlying account did
                if !account_ids_with_activity.is_empty() {
                    account_ids_with_activity.insert(PORTFOLIO_TOTAL_ACCOUNT_ID.to_string());
                }
            }
        }

        // Ensure all accounts being processed (even those with no activities) have an entry
        // This simplifies downstream logic that expects keys to exist.
        for acc_id in accounts_to_process.keys() {
            activities_by_account_date
                .entry(acc_id.clone())
                .or_default();
        }

        Ok((activities_by_account_date, account_ids_with_activity))
    }

    // --- Step 6: Determine calculation range and initial state (Keyframes) ---
    // Handles individual accounts and the TOTAL account distinctly.
    async fn determine_calculation_range_and_initial_state(
        &self,
        accounts_to_process: &AccountsMap, // Includes virtual TOTAL if needed
        activities_by_account_date: &ActivitiesByAccount, // Includes TOTAL key if needed
        account_ids_with_activity: &HashSet<String>, // Accounts that actually have activities
        force_full_calculation: bool,
        calculation_end_date: NaiveDate,
    ) -> Result<(StartSnapshotsMap, StartDatesMap, NaiveDate)> {
        debug!(
            "Determining calculation range. Accounts with activity: {:?}. Force full: {}",
            account_ids_with_activity.len(),
            force_full_calculation
        );
        let mut start_keyframes: StartSnapshotsMap = HashMap::new();
        let mut effective_start_dates: StartDatesMap = HashMap::new();
        let mut overall_min_calc_date = calculation_end_date;

        for (acc_id, account) in accounts_to_process {
            if !account_ids_with_activity.contains(acc_id) && !force_full_calculation {
                debug!("Skipping account {} for range determination: no activities and not forcing full.", acc_id);
                continue;
            }

            let min_activity_date_for_account = activities_by_account_date
                .get(acc_id)
                .and_then(|dates_map| dates_map.keys().next().cloned());

            let mut effective_start_date;
            let mut initial_snapshot_for_acc: Option<AccountStateSnapshot> = None;

            if force_full_calculation {
                effective_start_date =
                    min_activity_date_for_account.unwrap_or(calculation_end_date);
                debug!(
                    "Force full calculation: Setting effective_start_date for account {} to {}. Deletion handled by overwrite methods.",
                    acc_id, effective_start_date
                );
            } else if let Some(latest_snapshot) = self
                .snapshot_repository
                .get_latest_snapshot_before_date(acc_id, calculation_end_date)?
            {
                let snapshot_day = latest_snapshot.snapshot_date;
                // Resume from the last known keyframe. The calculator expects the in-memory
                // "previous" state to be the day before `effective_start_date`, so we start on
                // the day *after* the stored keyframe to avoid re-processing that day’s activities.
                initial_snapshot_for_acc = Some(latest_snapshot);
                effective_start_date = snapshot_day.succ_opt().unwrap_or(snapshot_day);
            } else {
                effective_start_date =
                    min_activity_date_for_account.unwrap_or(calculation_end_date);
                debug!(
                    "No snapshot found for account {}. Starting from earliest activity: {} or end_date.",
                    acc_id, effective_start_date
                );
            }

            if let Some(min_act_date) = min_activity_date_for_account {
                if initial_snapshot_for_acc.is_none() && min_act_date < effective_start_date {
                    debug!(
                        "Account {} has activities (at {}) before determined start_date ({}). Adjusting to earliest activity.",
                        acc_id, min_act_date, effective_start_date
                    );
                    effective_start_date = min_act_date;
                    initial_snapshot_for_acc = None;
                }
            }

            if effective_start_date <= calculation_end_date {
                if let Some(snapshot) = initial_snapshot_for_acc {
                    start_keyframes.insert(acc_id.clone(), snapshot);
                } else {
                    let day_before_effective_start = effective_start_date
                        .pred_opt()
                        .unwrap_or(effective_start_date);
                    start_keyframes.insert(
                        acc_id.clone(),
                        Self::create_initial_snapshot(account, day_before_effective_start),
                    );
                }
                effective_start_dates.insert(acc_id.clone(), effective_start_date);
                if effective_start_date < overall_min_calc_date {
                    overall_min_calc_date = effective_start_date;
                }
            } else {
                debug!("Skipping account {} for calculation: effective_start_date {} is after calculation_end_date {}.",
                       acc_id, effective_start_date, calculation_end_date);
            }
        }

        if effective_start_dates.is_empty() && !accounts_to_process.is_empty() {
            warn!(
                "No effective calculation periods determined for any accounts. Min calc date defaults to end date: {}",
                calculation_end_date
            );
            overall_min_calc_date = calculation_end_date;
        } else if effective_start_dates.is_empty() && accounts_to_process.is_empty() {
            debug!(
                "No accounts to process, min calc date defaults to end date: {}",
                calculation_end_date
            );
            overall_min_calc_date = calculation_end_date;
        }

        Ok((
            start_keyframes,
            effective_start_dates,
            overall_min_calc_date,
        ))
    }

    // --- Step 7: Calculate daily holdings snapshots (in memory) and identify keyframes ---
    // Iterates through dates and calculates holdings for each account needing processing (incl. TOTAL).
    // Returns (final_states, keyframes, warnings) - warnings contain info about activities that couldn't be processed.
    fn calculate_daily_holdings_snapshots(
        &self,
        accounts_needing_calculation: &AccountsMap, // Actual accounts to process
        activities_by_account_date: &ActivitiesByAccount, // Includes TOTAL key if needed
        start_keyframes: &StartSnapshotsMap, // Initial states for accounts needing calculation
        effective_start_dates: &StartDatesMap, // Start dates for accounts needing calculation
        calculation_min_date: NaiveDate,
        calculation_end_date: NaiveDate,
    ) -> Result<(
        HashMap<String, AccountStateSnapshot>, // Final states
        Vec<AccountStateSnapshot>,             // Keyframes to save
        Vec<HoldingsCalculationWarning>,       // Warnings for activities that couldn't be processed
    )> {
        let mut current_holdings_snapshots = start_keyframes.clone();
        let mut keyframes_to_save: Vec<AccountStateSnapshot> = Vec::new();
        let mut all_warnings: Vec<HoldingsCalculationWarning> = Vec::new();
        let date_range = get_days_between(calculation_min_date, calculation_end_date);

        for current_date in date_range {
            // Process only accounts whose effective start date is today or earlier
            let accounts_to_process_today: Vec<_> = accounts_needing_calculation
                .iter()
                .filter(|(id, _)| {
                    effective_start_dates
                        .get(*id)
                        .is_some_and(|start_date| *start_date <= current_date)
                })
                .collect();

            if accounts_to_process_today.is_empty() {
                // This shouldn't happen if calculation_min_date was determined correctly, but handle defensively.
                debug!(
                    "No accounts to process for date {}. Skipping day.",
                    current_date
                );
                continue;
            }

            let mut next_day_holdings_snapshots =
                HashMap::with_capacity(accounts_to_process_today.len());
            let mut keyframes_today = Vec::new();

            for (account_id, _account) in accounts_to_process_today {
                let previous_holdings_snapshot = current_holdings_snapshots
                    .get(account_id)
                     .ok_or_else(|| {
                         error!("CRITICAL: Missing previous holdings snapshot for account {} in memory map for date {}", account_id, current_date);
                         Error::Calculation(CalculatorError::Calculation(format!(
                             "Missing previous holdings snapshot for account {} for date {}",
                             account_id, current_date
                         )))
                     })?;

                // Get activities for THIS specific account (or the aggregated TOTAL activities)
                let activities_today = activities_by_account_date
                    .get(account_id) // Fetches individual or TOTAL activities based on account_id
                    .and_then(|date_map| date_map.get(&current_date))
                    .cloned()
                    .unwrap_or_default();

                let is_first_day = effective_start_dates.get(account_id) == Some(&current_date);
                let has_activities = !activities_today.is_empty();

                let current_holdings_snapshot: AccountStateSnapshot; // Final state for today

                if !has_activities {
                    // No activities today, just carry forward the previous state
                    let mut carried_forward_state = previous_holdings_snapshot.clone();
                    carried_forward_state.snapshot_date = current_date;
                    carried_forward_state.id =
                        format!("{}_{}", account_id, current_date.format("%Y-%m-%d"));
                    // Note: calculated_at remains the same as the previous snapshot
                    current_holdings_snapshot = carried_forward_state;
                } else {
                    // Activities occurred, call the calculator
                    match self.holdings_calculator.calculate_next_holdings(
                        previous_holdings_snapshot,
                        &activities_today, // Pass the already fetched activities
                        current_date,
                    ) {
                        Ok(calc_result) => {
                            // Collect any warnings from activity processing
                            if calc_result.has_warnings() {
                                for warning in &calc_result.warnings {
                                    warn!(
                                        "Holdings calculation warning for account {} on {}: {}",
                                        account_id, current_date, warning
                                    );
                                }
                                all_warnings.extend(calc_result.warnings);
                            }

                            // Calculator provides the new state, including updated calculated_at
                            current_holdings_snapshot = calc_result.snapshot;

                            debug!(
                                "Holdings calculated successfully for account {} on {}",
                                account_id, current_date
                            );
                        }
                        Err(e) => {
                            error!(
                                "Holdings calculation failed for account {} on {}: {}. Carrying forward previous state.",
                                account_id, current_date, e
                            );
                            // Carry forward the previous day's state on error
                            let mut errored_state = previous_holdings_snapshot.clone();
                            errored_state.snapshot_date = current_date; // Update date even if carried forward
                            errored_state.id =
                                format!("{}_{}", account_id, current_date.format("%Y-%m-%d"));
                            // calculated_at remains the same as the previous snapshot
                            current_holdings_snapshot = errored_state;
                        }
                    }
                }

                // Decide if it's a keyframe based on the determined snapshot
                // A keyframe is needed on the first day of calculation or if activities happened.
                let is_keyframe = is_first_day || has_activities;

                if is_keyframe {
                    // Create the keyframe based on the final state for today
                    let mut keyframe_snapshot = current_holdings_snapshot.clone();
                    // Ensure account_id and id are correctly set for the keyframe
                    keyframe_snapshot.account_id = account_id.clone();
                    keyframe_snapshot.id =
                        format!("{}_{}", account_id, current_date.format("%Y-%m-%d"));
                    keyframes_today.push(keyframe_snapshot);
                }

                // Store the calculated/carried-forward snapshot for the next iteration's "previous" state
                next_day_holdings_snapshots
                    .insert(account_id.to_string(), current_holdings_snapshot); // Use the final determined snapshot
            }

            // Update the main state map for the next day
            // Important: Only update states for accounts processed today.
            for (id, state) in next_day_holdings_snapshots {
                current_holdings_snapshots.insert(id, state);
            }
            keyframes_to_save.extend(keyframes_today);
        }

        // Log summary of warnings if any occurred
        if !all_warnings.is_empty() {
            warn!(
                "Holdings calculation completed with {} warning(s) for activities that could not be processed",
                all_warnings.len()
            );
        }

        // Return the final holdings states, keyframes, and any warnings
        Ok((current_holdings_snapshots, keyframes_to_save, all_warnings))
    }

    // Renamed and refined from the previous aggregate_total_portfolio_snapshot
    fn generate_total_portfolio_snapshot_for_date(
        &self,
        target_date: NaiveDate,
        // Map of Account ID -> AccountStateSnapshot for all *individual* accounts as of target_date
        individual_snapshots_on_date: &HashMap<String, AccountStateSnapshot>,
        base_portfolio_currency: &str,
        internal_transfer_adjustment_base_ccy: Decimal,
    ) -> Result<AccountStateSnapshot> {
        let mut aggregated_cash_balances: HashMap<String, Decimal> = HashMap::new();
        let mut aggregated_positions: HashMap<String, Position> = HashMap::new(); // Position struct from crate::portfolio::snapshot::Position
        let mut overall_cost_basis_base_ccy = Decimal::ZERO;
        let mut overall_net_contribution_base_ccy = Decimal::ZERO;

        for (individual_acc_id, individual_snapshot) in individual_snapshots_on_date {
            // Ensure we are only processing individual accounts here, not an old TOTAL snapshot if it exists in the input map
            if individual_acc_id == PORTFOLIO_TOTAL_ACCOUNT_ID {
                continue;
            }

            // 1. Aggregate Cash Balances
            // Iterate over all cash balances in the individual snapshot (which might be multi-currency)
            // and add them to the corresponding currency in the aggregated map.
            for (currency, amount) in &individual_snapshot.cash_balances {
                *aggregated_cash_balances
                    .entry(currency.clone())
                    .or_insert(Decimal::ZERO) += *amount;
            }

            // 2. Aggregate Net Contribution (already frozen FX)
            overall_net_contribution_base_ccy += individual_snapshot.net_contribution_base;

            // 3. Aggregate Positions & Calculate Overall Cost Basis for TOTAL (in base_portfolio_currency)
            for pos in individual_snapshot.positions.values() {
                let agg_pos = aggregated_positions
                    .entry(pos.asset_id.clone())
                    .or_insert_with(|| Position {
                        id: format!("{}_{}", pos.asset_id, PORTFOLIO_TOTAL_ACCOUNT_ID),
                        account_id: PORTFOLIO_TOTAL_ACCOUNT_ID.to_string(),
                        asset_id: pos.asset_id.clone(),
                        quantity: Decimal::ZERO,
                        average_cost: Decimal::ZERO,
                        total_cost_basis: Decimal::ZERO, // This will be in asset's currency (pos.currency)
                        currency: pos.currency.clone(),
                        lots: VecDeque::new(),
                        inception_date: pos.inception_date,
                        created_at: Utc::now(),
                        last_updated: Utc::now(),
                        is_alternative: pos.is_alternative, // Inherit from source position
                    });

                agg_pos.quantity += pos.quantity;
                agg_pos.total_cost_basis += pos.total_cost_basis; // Summing in asset's currency
                if pos.inception_date < agg_pos.inception_date {
                    agg_pos.inception_date = pos.inception_date;
                }

                if !pos.lots.is_empty() {
                    let agg_position_id = agg_pos.id.clone();
                    agg_pos
                        .lots
                        .extend(pos.lots.iter().cloned().map(|mut lot: Lot| {
                            lot.position_id = agg_position_id.clone();
                            lot
                        }));
                }

                // Convert this specific position's total_cost_basis (in asset currency) to base_portfolio_currency
                // and add to the portfolio's overall cost_basis.
                match self
                    .holdings_calculator
                    .fx_service
                    .convert_currency_for_date(
                        pos.total_cost_basis,
                        &pos.currency,
                        base_portfolio_currency,
                        target_date,
                    ) {
                    Ok(converted_pos_cost_basis) => {
                        overall_cost_basis_base_ccy += converted_pos_cost_basis;
                    }
                    Err(e) => {
                        warn!(
                            "Failed to convert position cost basis for asset {} ({} {} to {}) for TOTAL on {}: {}. Adding unconverted.",
                            pos.asset_id, pos.total_cost_basis, pos.currency, base_portfolio_currency, target_date, e
                        );
                        if pos.currency != base_portfolio_currency {
                            overall_cost_basis_base_ccy += pos.total_cost_basis;
                        // Fallback
                        } else {
                            overall_cost_basis_base_ccy += pos.total_cost_basis;
                            // Already in base
                        }
                    }
                }
            }
        }

        // Finalize average costs for aggregated positions
        for agg_pos in aggregated_positions.values_mut() {
            if agg_pos.lots.len() > 1 {
                let mut sorted_lots: Vec<_> = agg_pos.lots.drain(..).collect();
                sorted_lots.sort_by_key(|lot| lot.acquisition_date);
                agg_pos.lots = sorted_lots.into();
            }

            if !agg_pos.quantity.is_zero() {
                agg_pos.average_cost =
                    (agg_pos.total_cost_basis / agg_pos.quantity).round_dp(DECIMAL_PRECISION);
            } else {
                agg_pos.average_cost = Decimal::ZERO;
                agg_pos.total_cost_basis = Decimal::ZERO;
            }
        }

        // Compute cash totals for TOTAL snapshot (denominated in base currency)
        let mut cash_total_base = Decimal::ZERO;
        for (currency, &amount) in &aggregated_cash_balances {
            if currency == base_portfolio_currency {
                cash_total_base += amount;
            } else {
                // Convert to base currency
                match self
                    .holdings_calculator
                    .fx_service
                    .convert_currency_for_date(
                        amount,
                        currency,
                        base_portfolio_currency,
                        target_date,
                    ) {
                    Ok(converted) => cash_total_base += converted,
                    Err(e) => {
                        warn!(
                            "Failed to convert cash {} {} to base currency {}: {}. Using unconverted.",
                            amount, currency, base_portfolio_currency, e
                        );
                        cash_total_base += amount;
                    }
                }
            }
        }

        Ok(AccountStateSnapshot {
            id: format!(
                "{}_{}",
                PORTFOLIO_TOTAL_ACCOUNT_ID,
                target_date.format("%Y-%m-%d")
            ),
            account_id: PORTFOLIO_TOTAL_ACCOUNT_ID.to_string(),
            snapshot_date: target_date,
            currency: base_portfolio_currency.to_string(), // TOTAL snapshot is denominated in base currency
            cash_balances: aggregated_cash_balances, // Itemized by account currency holding the cash
            positions: aggregated_positions,
            cost_basis: overall_cost_basis_base_ccy.round_dp(DECIMAL_PRECISION),
            net_contribution: (overall_net_contribution_base_ccy
                - internal_transfer_adjustment_base_ccy)
                .round_dp(DECIMAL_PRECISION),
            net_contribution_base: (overall_net_contribution_base_ccy
                - internal_transfer_adjustment_base_ccy)
                .round_dp(DECIMAL_PRECISION),
            // For TOTAL snapshot, account_currency == base_currency
            cash_total_account_currency: cash_total_base.round_dp(DECIMAL_PRECISION),
            cash_total_base_currency: cash_total_base.round_dp(DECIMAL_PRECISION),
            calculated_at: Utc::now().naive_utc(),
            source: SnapshotSource::Calculated,
        })
    }

    fn internal_transfer_adjustments_by_date_base(
        &self,
        account_ids: &[String],
        base_currency: &str,
    ) -> Result<HashMap<NaiveDate, Decimal>> {
        let activities = self
            .activity_repository
            .get_activities_by_account_ids(account_ids)?;

        let mut grouped: HashMap<String, Vec<Activity>> = HashMap::new();
        for activity in activities {
            if activity.source_group_id.is_none() {
                continue;
            }

            let activity_type = activity.activity_type.as_str();
            if activity_type != crate::activities::ACTIVITY_TYPE_TRANSFER_IN
                && activity_type != crate::activities::ACTIVITY_TYPE_TRANSFER_OUT
            {
                continue;
            }

            if classify_flow_for_scope(&activity, PerformanceScope::Portfolio) == FlowType::External
            {
                continue;
            }

            if let Some(group_id) = activity.source_group_id.clone() {
                grouped.entry(group_id).or_default().push(activity);
            }
        }

        let mut adjustments_by_date: HashMap<NaiveDate, Decimal> = HashMap::new();

        for (_group_id, group_activities) in grouped {
            let has_in = group_activities
                .iter()
                .any(|a| a.activity_type == crate::activities::ACTIVITY_TYPE_TRANSFER_IN);
            let has_out = group_activities
                .iter()
                .any(|a| a.activity_type == crate::activities::ACTIVITY_TYPE_TRANSFER_OUT);

            if !(has_in && has_out) {
                continue;
            }

            for activity in group_activities {
                let amount = if let Some(amount) = activity.amount {
                    amount
                } else if let (Some(quantity), Some(unit_price)) =
                    (activity.quantity, activity.unit_price)
                {
                    quantity * unit_price
                } else {
                    Decimal::ZERO
                };

                if amount.is_zero() {
                    continue;
                }

                let activity_date = activity.activity_date.naive_utc().date();
                let amount_base = if activity.currency == base_currency {
                    amount
                } else {
                    match self
                        .holdings_calculator
                        .fx_service
                        .convert_currency_for_date(
                            amount,
                            &activity.currency,
                            base_currency,
                            activity_date,
                        ) {
                        Ok(converted) => converted,
                        Err(e) => {
                            warn!(
                                "Failed to convert transfer amount {} {} to base {} on {}: {}. Using unconverted.",
                                amount, activity.currency, base_currency, activity_date, e
                            );
                            amount
                        }
                    }
                };

                let signed_amount =
                    if activity.activity_type == crate::activities::ACTIVITY_TYPE_TRANSFER_IN {
                        amount_base
                    } else {
                        -amount_base
                    };

                *adjustments_by_date
                    .entry(activity_date)
                    .or_insert(Decimal::ZERO) += signed_amount;
            }
        }

        Ok(adjustments_by_date)
    }

    // --- Helpers ---

    // create_initial_snapshot creates a snapshot with default values
    fn create_initial_snapshot(account: &Account, date: NaiveDate) -> AccountStateSnapshot {
        AccountStateSnapshot {
            id: format!("{}_{}", account.id, date.format("%Y-%m-%d")),
            account_id: account.id.clone(),
            snapshot_date: date,
            currency: account.currency.clone(),
            positions: HashMap::new(),
            cash_balances: HashMap::new(),
            cost_basis: Decimal::ZERO,
            net_contribution: Decimal::ZERO,
            net_contribution_base: Decimal::ZERO,
            cash_total_account_currency: Decimal::ZERO,
            cash_total_base_currency: Decimal::ZERO,
            calculated_at: Utc::now().naive_utc(),
            source: SnapshotSource::Calculated,
        }
    }

    // (Helper function group_activities_by_account_and_date moved inside preprocess_data)

    fn calculate_split_factors(
        &self,
        activities: &[Activity],
        start_date: NaiveDate,
        end_date: NaiveDate,
    ) -> HashMap<String, Vec<(NaiveDate, Decimal)>> {
        use crate::activities::ACTIVITY_TYPE_SPLIT;
        let mut split_factors: HashMap<String, Vec<(NaiveDate, Decimal)>> = HashMap::new();
        for activity in activities.iter().filter(|a| {
            a.activity_type == ACTIVITY_TYPE_SPLIT
                && a.activity_date.naive_utc().date() >= start_date
                && a.activity_date.naive_utc().date() <= end_date
        }) {
            // Check if the activity amount exists and represents a valid positive split ratio
            let asset_id = match &activity.asset_id {
                Some(id) => id,
                None => {
                    warn!(
                        "Missing asset_id for Split activity {} on {}. Ignoring split.",
                        activity.id, activity.activity_date
                    );
                    continue;
                }
            };
            if let Some(split_ratio) = activity.amount {
                if split_ratio.is_sign_positive() && !split_ratio.is_zero() {
                    // Collect valid splits (date, ratio) for the asset
                    split_factors
                        .entry(asset_id.clone())
                        .or_default() // Get the Vec, create if needed
                        .push((activity.activity_date.naive_utc().date(), split_ratio));
                // Push (date, ratio) tuple
                } else {
                    // Log warning for invalid ratio (e.g., zero or negative)
                    warn!(
                        "Invalid split ratio {} for Split activity {} on {}. Ignoring split.",
                        split_ratio, activity.id, activity.activity_date
                    );
                }
            } else {
                // Log warning if amount is missing for a split activity
                warn!(
                    "Missing amount for Split activity {} for asset {} on {}. Ignoring split.",
                    activity.id, asset_id, activity.activity_date
                );
            }
        }
        for splits in split_factors.values_mut() {
            splits.sort_by_key(|k| k.0);
        }
        split_factors
    }

    fn adjust_activities_for_splits(
        &self,
        activities: &[Activity],
        split_factors: &HashMap<String, Vec<(NaiveDate, Decimal)>>,
    ) -> Vec<Activity> {
        use crate::activities::ACTIVITY_TYPE_SPLIT;

        let mut adjusted_activities = Vec::with_capacity(activities.len());
        for activity in activities {
            let mut adj_activity = activity.clone();
            let asset_id = match &activity.asset_id {
                Some(id) => id,
                None => {
                    // No asset_id, just push the activity as-is
                    adjusted_activities.push(adj_activity);
                    continue;
                }
            };
            if let Some(splits) = split_factors.get(asset_id) {
                // Do not adjust the SPLIT activity itself, only others
                if adj_activity.activity_type != ACTIVITY_TYPE_SPLIT {
                    let mut cumulative_factor = Decimal::ONE;
                    // Apply splits that happened *after* the activity date
                    for (split_date, split_ratio) in splits.iter() {
                        // Iterate chronologically
                        if *split_date > adj_activity.activity_date.naive_utc().date() {
                            // Split happened after this activity, need to adjust past quantity/price
                            cumulative_factor *= split_ratio;
                        }
                    }

                    if cumulative_factor != Decimal::ONE {
                        debug!(
                            "Adjusting activity {} on {} for asset {} due to future splits. Factor: {}",
                            adj_activity.id, adj_activity.activity_date.naive_utc().date(), asset_id, cumulative_factor
                        );
                        // Adjust quantity
                        // Use correct field name 'quantity'
                        adj_activity.quantity =
                            Some((activity.qty() * cumulative_factor).round_dp(DECIMAL_PRECISION));

                        // Adjust unit price (inverse factor)
                        // Use correct field name 'unit_price'
                        let unit_price = activity.price();
                        if !unit_price.is_zero() {
                            if !cumulative_factor.is_zero() {
                                // Avoid division by zero
                                // Use correct field name 'unit_price'
                                adj_activity.unit_price = Some(
                                    (unit_price / cumulative_factor).round_dp(DECIMAL_PRECISION),
                                );
                            } else {
                                warn!("Cumulative split factor is zero for activity {}. Cannot adjust unit price.", adj_activity.id);
                                // Use correct field name 'unit_price'
                                adj_activity.unit_price = Some(Decimal::ZERO); // Or handle as error?
                            }
                        }
                    }
                }
            }
            adjusted_activities.push(adj_activity);
        }
        adjusted_activities
    }

    // --- New method to calculate and store TOTAL portfolio snapshots ---
    async fn calculate_total_portfolio_snapshots_impl(
        &self,
        force_full_calculation: bool,
    ) -> Result<usize> {
        debug!(
            "Starting calculation of TOTAL portfolio snapshots (force={})",
            force_full_calculation
        );

        // Use non-archived accounts for TOTAL calculation (includes closed but not archived accounts)
        let non_archived_accounts = self.account_repository.list(None, Some(false), None)?;
        if non_archived_accounts.is_empty() {
            warn!("No non-archived accounts found. Cannot generate TOTAL snapshots.");
            self.snapshot_repository
                .overwrite_all_snapshots_for_account(PORTFOLIO_TOTAL_ACCOUNT_ID, &[])
                .await?;
            return Ok(0);
        }

        let all_individual_keyframes = self
            .snapshot_repository
            .get_all_non_archived_account_snapshots(None, None)?;

        if all_individual_keyframes.is_empty() {
            warn!("No keyframes found for any non-archived individual accounts. Cannot generate TOTAL snapshots.");
            self.snapshot_repository
                .overwrite_all_snapshots_for_account(PORTFOLIO_TOTAL_ACCOUNT_ID, &[])
                .await?;
            info!("Cleaned any existing TOTAL snapshots as no new ones were generated.");
            return Ok(0);
        }

        let mut keyframes_by_account: HashMap<String, BTreeMap<NaiveDate, AccountStateSnapshot>> =
            HashMap::new();
        let mut all_snapshot_dates: HashSet<NaiveDate> = HashSet::new();
        let mut max_individual_keyframe_date: Option<NaiveDate> = None;

        for keyframe in all_individual_keyframes {
            if keyframe.account_id == PORTFOLIO_TOTAL_ACCOUNT_ID {
                continue;
            }
            all_snapshot_dates.insert(keyframe.snapshot_date);
            // Track the max date across all individual keyframes
            max_individual_keyframe_date = Some(
                max_individual_keyframe_date
                    .map(|d| d.max(keyframe.snapshot_date))
                    .unwrap_or(keyframe.snapshot_date),
            );
            keyframes_by_account
                .entry(keyframe.account_id.clone())
                .or_default()
                .insert(keyframe.snapshot_date, keyframe);
        }

        if all_snapshot_dates.is_empty() {
            info!("No individual account keyframes found after processing. Cannot generate TOTAL snapshots.");
            return Ok(0);
        }

        // --- Incremental calculation logic (skip if already up-to-date) ---
        let calculation_start_date: Option<NaiveDate>;

        if force_full_calculation {
            debug!("Force full calculation: will regenerate all TOTAL snapshots.");
            calculation_start_date = None; // Calculate all dates
        } else {
            // Check if TOTAL is already up-to-date
            let today = valuation_date_today();
            let tomorrow = today.succ_opt().unwrap_or(today);
            let latest_total_snapshot = self
                .snapshot_repository
                .get_latest_snapshot_before_date(PORTFOLIO_TOTAL_ACCOUNT_ID, tomorrow)?;

            if let Some(ref total_snapshot) = latest_total_snapshot {
                if let Some(max_date) = max_individual_keyframe_date {
                    if total_snapshot.snapshot_date >= max_date {
                        debug!(
                            "TOTAL snapshots already up-to-date (latest TOTAL: {}, max individual: {}). Skipping recalculation.",
                            total_snapshot.snapshot_date, max_date
                        );
                        return Ok(0);
                    }
                    // Only calculate from the day after the latest TOTAL snapshot
                    calculation_start_date = total_snapshot.snapshot_date.succ_opt();
                    debug!(
                        "Incremental TOTAL calculation from {} (latest TOTAL: {}, max individual: {})",
                        calculation_start_date.unwrap_or(total_snapshot.snapshot_date),
                        total_snapshot.snapshot_date,
                        max_date
                    );
                } else {
                    calculation_start_date = None;
                }
            } else {
                debug!("No existing TOTAL snapshots. Will calculate all dates.");
                calculation_start_date = None;
            }
        }

        let base_portfolio_currency = self.base_currency.read().unwrap().clone();
        let mut total_portfolio_snapshots_to_save: Vec<AccountStateSnapshot> = Vec::new();

        let mut sorted_snapshot_dates: Vec<NaiveDate> = all_snapshot_dates.into_iter().collect();
        sorted_snapshot_dates.sort();

        // Filter dates based on calculation_start_date for incremental calculation
        let dates_to_calculate: Vec<NaiveDate> = if let Some(start_date) = calculation_start_date {
            sorted_snapshot_dates
                .iter()
                .filter(|&&date| date >= start_date)
                .copied()
                .collect()
        } else {
            sorted_snapshot_dates.clone()
        };

        if dates_to_calculate.is_empty() {
            debug!("No new dates to calculate for TOTAL snapshots.");
            return Ok(0);
        }

        let account_ids: Vec<String> = non_archived_accounts
            .iter()
            .filter(|account| account.id != PORTFOLIO_TOTAL_ACCOUNT_ID)
            .map(|account| account.id.clone())
            .collect();
        let transfer_adjustments_by_date = self
            .internal_transfer_adjustments_by_date_base(&account_ids, &base_portfolio_currency)?;

        // Calculate cumulative transfer adjustment up to (but not including) the first date we're calculating
        let mut cumulative_transfer_adjustment = Decimal::ZERO;
        if let Some(start_date) = calculation_start_date {
            for date in &sorted_snapshot_dates {
                if *date >= start_date {
                    break;
                }
                if let Some(adjustment) = transfer_adjustments_by_date.get(date) {
                    cumulative_transfer_adjustment += *adjustment;
                }
            }
        }

        for target_date in dates_to_calculate {
            if let Some(adjustment) = transfer_adjustments_by_date.get(&target_date) {
                cumulative_transfer_adjustment += *adjustment;
            }

            let mut individual_snapshots_on_or_before_date: HashMap<String, AccountStateSnapshot> =
                HashMap::new();

            for (account_id, account_keyframes) in &keyframes_by_account {
                if let Some((_, latest_snapshot)) = account_keyframes.range(..=target_date).last() {
                    individual_snapshots_on_or_before_date
                        .insert(account_id.clone(), latest_snapshot.clone());
                }
            }

            if !individual_snapshots_on_or_before_date.is_empty() {
                match self.generate_total_portfolio_snapshot_for_date(
                    target_date,
                    &individual_snapshots_on_or_before_date,
                    &base_portfolio_currency,
                    cumulative_transfer_adjustment,
                ) {
                    Ok(total_snapshot) => {
                        total_portfolio_snapshots_to_save.push(total_snapshot);
                    }
                    Err(e) => {
                        error!(
                            "Failed to generate TOTAL portfolio snapshot for target_date {}: {}",
                            target_date, e
                        );
                    }
                }
            }
        }

        if !total_portfolio_snapshots_to_save.is_empty() {
            info!(
                "Saving {} new TOTAL portfolio snapshots.",
                total_portfolio_snapshots_to_save.len()
            );

            if force_full_calculation || calculation_start_date.is_none() {
                // Full recalculation: overwrite all
                self.snapshot_repository
                    .overwrite_all_snapshots_for_account(
                        PORTFOLIO_TOTAL_ACCOUNT_ID,
                        &total_portfolio_snapshots_to_save,
                    )
                    .await?;
            } else {
                // Incremental: append new snapshots (save_or_update each)
                for snapshot in &total_portfolio_snapshots_to_save {
                    self.snapshot_repository
                        .save_or_update_snapshot(snapshot)
                        .await?;
                }
            }

            // Note: We intentionally do NOT emit HoldingsChanged here.
            // This method is called during portfolio recalculation (triggered by domain events).
            // Emitting events here would create an infinite loop.

            Ok(total_portfolio_snapshots_to_save.len())
        } else {
            if force_full_calculation {
                warn!("No TOTAL portfolio snapshots were generated to save. Deleting existing TOTAL snapshots.");
                self.snapshot_repository
                    .overwrite_all_snapshots_for_account(PORTFOLIO_TOTAL_ACCOUNT_ID, &[])
                    .await?;
                info!("Cleaned any existing TOTAL snapshots as no new ones were generated.");
            }
            Ok(0)
        }
    }
}

#[async_trait]
impl SnapshotServiceTrait for SnapshotService {
    async fn calculate_holdings_snapshots(&self, account_ids: Option<&[String]>) -> Result<usize> {
        self.calculate_holdings_snapshots_internal(account_ids, false)
            .await
    }

    async fn force_recalculate_holdings_snapshots(
        &self,
        account_ids: Option<&[String]>,
    ) -> Result<usize> {
        self.calculate_holdings_snapshots_internal(account_ids, true)
            .await
    }

    fn get_holdings_keyframes(
        &self,
        account_id: &str,
        start_date_opt: Option<NaiveDate>,
        end_date_opt: Option<NaiveDate>,
    ) -> Result<Vec<AccountStateSnapshot>> {
        debug!(
            "Getting saved holdings keyframes for {} from {:?} to {:?}",
            account_id, start_date_opt, end_date_opt
        );
        // Directly fetch from the repository without reconstruction
        self.snapshot_repository
            .get_snapshots_by_account(account_id, start_date_opt, end_date_opt)
    }

    fn get_daily_holdings_snapshots(
        &self,
        account_id: &str,
        start_date_opt: Option<NaiveDate>,
        end_date_opt: Option<NaiveDate>,
    ) -> Result<Vec<AccountStateSnapshot>> {
        debug!(
            "Reconstructing daily holdings snapshots for {} from {:?} to {:?}",
            account_id, start_date_opt, end_date_opt
        );

        // Determine start date: Use provided, else earliest snapshot date
        let earliest_snapshot_date = self
            .snapshot_repository
            .get_earliest_snapshot_date(account_id)?;

        let start_date = match start_date_opt {
            Some(date) => date,
            None => match earliest_snapshot_date {
                Some(date) => date,
                None => {
                    debug!(
                        "No snapshots found for account {}. Returning empty.",
                        account_id
                    );
                    return Ok(Vec::new());
                }
            },
        };

        // Use provided end_date, or latest snapshot date, or today as fallback
        let end_date = match end_date_opt {
            Some(date) => date,
            None => {
                // Get the latest snapshot to ensure we include all available data
                // Use a far future date to get the absolute latest snapshot
                let today = valuation_date_today();
                let far_future = today + chrono::Duration::days(365);
                match self
                    .snapshot_repository
                    .get_latest_snapshot_before_date(account_id, far_future)?
                {
                    Some(latest_snapshot) => latest_snapshot.snapshot_date.max(today),
                    None => today,
                }
            }
        };

        if start_date > end_date {
            warn!(
                "get_daily_holdings_snapshots: Start date {} is after end date {}. Returning empty.",
                start_date, end_date
            );
            return Ok(Vec::new());
        }

        // Fetch keyframes within the actual range first, as we might need them to determine the initial state.
        let keyframes_in_range = self.snapshot_repository.get_snapshots_by_account(
            account_id,
            Some(start_date), // Fetch keyframes from start_date...
            Some(end_date),   // ...to end_date inclusive
        )?;
        let keyframes_map: BTreeMap<NaiveDate, AccountStateSnapshot> = keyframes_in_range
            .into_iter()
            .map(|kf| (kf.snapshot_date, kf))
            .collect();

        // Try to get the state from the day before the loop starts.
        let initial_state_result = self
            .snapshot_repository
            .get_latest_snapshot_before_date(account_id, start_date);

        let mut current_state = match initial_state_result? {
            Some(initial_snapshot) => initial_snapshot,
            None => {
                // No snapshot found before start date.
                // If there are no keyframes at all in the requested range, we can't reconstruct.
                if keyframes_map.is_empty() {
                    debug!("No snapshot found before start date {} and no keyframes in range for account {}. Returning empty.", start_date, account_id);
                    return Ok(Vec::new());
                }

                // Otherwise, history starts within our date range. We create a default "empty" state
                // for the day before the loop, and the loop will then pick up the first keyframe correctly.
                let account_details =
                    self.account_repository.get_by_id(account_id).or_else(|_| {
                        if account_id == PORTFOLIO_TOTAL_ACCOUNT_ID {
                            Ok(self.create_total_virtual_account())
                        } else {
                            Err(Error::Repository(format!(
                                "Account not found while reconstructing daily snapshots: {}",
                                account_id
                            )))
                        }
                    })?;
                let day_before_start = start_date.pred_opt().unwrap_or(start_date);
                Self::create_initial_snapshot(&account_details, day_before_start)
            }
        };

        let capacity = (end_date - start_date).num_days().try_into().unwrap_or(0) + 1;
        let mut reconstructed_snapshots = Vec::with_capacity(capacity);
        let date_range = get_days_between(start_date, end_date);

        for current_date in date_range {
            if let Some(saved_keyframe) = keyframes_map.get(&current_date) {
                // Use the saved keyframe for this date
                current_state = saved_keyframe.clone();
                reconstructed_snapshots.push(saved_keyframe.clone());
            } else {
                // Reconstruct by carrying forward the previous day's state
                let mut reconstructed = current_state.clone();
                reconstructed.snapshot_date = current_date;
                reconstructed.id = format!(
                    "{}_{}",
                    reconstructed.account_id,
                    current_date.format("%Y-%m-%d")
                );
                // Removed lines attempting to reset non-existent valuation fields
                reconstructed.calculated_at = Utc::now().naive_utc(); // Mark when it was reconstructed

                current_state = reconstructed.clone(); // Update state for the next day
                reconstructed_snapshots.push(reconstructed);
            }
        }

        Ok(reconstructed_snapshots)
    }

    fn get_latest_holdings_snapshot(
        &self,
        account_id: &str,
    ) -> Result<Option<AccountStateSnapshot>> {
        let today = valuation_date_today();
        // The date passed to get_latest_snapshot_before_date is exclusive, so use tomorrow to include today.
        let tomorrow = today.succ_opt().unwrap_or(today);
        match self
            .snapshot_repository
            .get_latest_snapshot_before_date(account_id, tomorrow)?
        {
            Some(snapshot) => Ok(Some(snapshot)),
            None => {
                // It's possible no snapshot exists yet, which is not necessarily an error,
                // but we should inform the caller.
                debug!(
                    "No snapshot found for account {} on or before {}",
                    account_id, today
                );
                Ok(None)
            }
        }
    }

    async fn calculate_total_portfolio_snapshots(&self) -> Result<usize> {
        self.calculate_total_portfolio_snapshots_impl(false).await
    }

    async fn force_recalculate_total_portfolio_snapshots(&self) -> Result<usize> {
        self.calculate_total_portfolio_snapshots_impl(true).await
    }

    async fn save_manual_snapshot(
        &self,
        account_id: &str,
        mut snapshot: AccountStateSnapshot,
    ) -> Result<()> {
        // Ensure the snapshot has the correct account_id
        snapshot.account_id = account_id.to_string();

        // Note: snapshot.source is preserved from the caller (ManualEntry or CsvImport)

        // Generate the snapshot ID based on account_id and date
        snapshot.id = format!(
            "{}_{}",
            account_id,
            snapshot.snapshot_date.format("%Y-%m-%d")
        );

        // Check if content is unchanged from latest snapshot (skip if identical)
        let latest = self.snapshot_repository.get_latest_snapshot_before_date(
            account_id,
            snapshot.snapshot_date + chrono::Days::new(1),
        )?;

        if let Some(existing) = latest {
            if existing.is_content_equal(&snapshot) {
                debug!(
                    "Snapshot content unchanged for account {} on {}, skipping save",
                    account_id, snapshot.snapshot_date
                );
                return Ok(());
            }
        }

        // Update the calculated_at timestamp
        snapshot.calculated_at = Utc::now().naive_utc();

        // Save or update the snapshot using repository method
        self.snapshot_repository
            .save_or_update_snapshot(&snapshot)
            .await?;

        info!(
            "Saved manual snapshot for account {} on date {}",
            account_id, snapshot.snapshot_date
        );

        // Emit HoldingsChanged event after successful save
        let asset_ids: Vec<String> = snapshot
            .positions
            .values()
            .map(|p| p.asset_id.clone())
            .collect();
        self.emit_holdings_changed(vec![account_id.to_string()], asset_ids);

        // Ensure holdings history has at least 2 snapshots
        self.ensure_holdings_history(account_id).await?;

        Ok(())
    }

    async fn update_snapshots_source(&self, account_id: &str, new_source: &str) -> Result<usize> {
        debug!(
            "Updating snapshot source for account {} to {}",
            account_id, new_source
        );

        let updated_count = self
            .snapshot_repository
            .update_snapshots_source(account_id, new_source)
            .await?;

        info!(
            "Updated {} snapshots for account {} to source {}",
            updated_count, account_id, new_source
        );

        Ok(updated_count)
    }

    async fn ensure_holdings_history(&self, account_id: &str) -> Result<()> {
        // Get count of non-calculated snapshots
        let count = self
            .snapshot_repository
            .get_non_calculated_snapshot_count(account_id)?;

        if count >= 2 {
            debug!(
                "Account {} already has {} non-calculated snapshots, no synthetic needed",
                account_id, count
            );
            return Ok(());
        }

        if count == 0 {
            debug!(
                "Account {} has no non-calculated snapshots, nothing to backfill from",
                account_id
            );
            return Ok(());
        }

        // count == 1: Create synthetic snapshot 3 months before the earliest
        let earliest = self
            .snapshot_repository
            .get_earliest_non_calculated_snapshot(account_id)?;

        let earliest = match earliest {
            Some(s) => s,
            None => {
                debug!("No earliest snapshot found for account {}", account_id);
                return Ok(());
            }
        };

        // Calculate synthetic date: 3 months before earliest
        let synthetic_date = earliest
            .snapshot_date
            .checked_sub_months(Months::new(3))
            .unwrap_or(earliest.snapshot_date);

        // Don't create if synthetic date equals earliest (edge case)
        if synthetic_date == earliest.snapshot_date {
            debug!(
                "Synthetic date equals earliest date for account {}, skipping",
                account_id
            );
            return Ok(());
        }

        // Clone the earliest snapshot with new date and source
        let synthetic = AccountStateSnapshot {
            id: format!("{}_{}", account_id, synthetic_date.format("%Y-%m-%d")),
            account_id: account_id.to_string(),
            snapshot_date: synthetic_date,
            source: SnapshotSource::Synthetic,
            calculated_at: Utc::now().naive_utc(),
            // Clone all holdings data from earliest
            currency: earliest.currency,
            positions: earliest.positions,
            cash_balances: earliest.cash_balances,
            cost_basis: earliest.cost_basis,
            net_contribution: earliest.net_contribution,
            net_contribution_base: earliest.net_contribution_base,
            cash_total_account_currency: earliest.cash_total_account_currency,
            cash_total_base_currency: earliest.cash_total_base_currency,
        };

        self.snapshot_repository
            .save_or_update_snapshot(&synthetic)
            .await?;

        info!(
            "Created synthetic snapshot for account {} at {} (3 months before {})",
            account_id, synthetic_date, earliest.snapshot_date
        );

        Ok(())
    }
}
