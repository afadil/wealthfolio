//! Asset ID utilities.
//!
//! With v2, asset IDs are opaque UUIDs generated by the database.
//! This module retains only symbol parsing helpers needed by other modules.
//! The typed prefix ID system (SEC:AAPL:XNAS) is removed.

use wealthfolio_market_data::{strip_yahoo_suffix, yahoo_exchange_suffixes, yahoo_suffix_to_mic};

/// Parse crypto pair symbols like "BTC-USD" or "BTC-USDT" into (base, quote).
/// Returns None if the symbol doesn't match the expected pair pattern.
pub fn parse_crypto_pair_symbol(symbol: &str) -> Option<(String, String)> {
    let trimmed = symbol.trim();
    let (base, quote) = trimmed.rsplit_once('-')?;
    let base = base.trim();
    let quote = quote.trim();
    if base.is_empty() || quote.is_empty() {
        return None;
    }
    let quote_upper = quote.to_uppercase();
    let quote_len = quote_upper.len();
    if !(3..=5).contains(&quote_len) || !quote_upper.chars().all(|c| c.is_ascii_alphabetic()) {
        return None;
    }
    Some((base.to_string(), quote_upper))
}

/// Parses a symbol that may contain a Yahoo Finance exchange suffix and extracts
/// the base symbol and exchange MIC.
///
/// Yahoo Finance uses suffixes like `.TO` (Toronto), `.L` (London), `.DE` (XETRA)
/// to indicate the exchange. This function strips the suffix and maps it to the
/// canonical MIC (Market Identifier Code).
///
/// # Returns
///
/// A tuple of (base_symbol, Option<mic>):
/// - `base_symbol`: The symbol without the suffix (e.g., "SHOP", "VOD", "AAPL")
/// - `mic`: The exchange MIC if a known suffix was found (e.g., Some("XTSE"), Some("XLON"), None)
pub fn parse_symbol_with_exchange_suffix(symbol: &str) -> (&str, Option<&'static str>) {
    let base_symbol = strip_yahoo_suffix(symbol);

    let mic = yahoo_exchange_suffixes()
        .iter()
        .find(|suffix| symbol.ends_with(*suffix))
        .and_then(|suffix| {
            let suffix_without_dot = &suffix[1..];
            yahoo_suffix_to_mic(suffix_without_dot)
        });

    (base_symbol, mic)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_crypto_pair_symbol() {
        assert_eq!(
            parse_crypto_pair_symbol("BTC-USD"),
            Some(("BTC".to_string(), "USD".to_string()))
        );
        assert_eq!(
            parse_crypto_pair_symbol("BTC-USDT"),
            Some(("BTC".to_string(), "USDT".to_string()))
        );
        assert_eq!(
            parse_crypto_pair_symbol("X-AI-USD"),
            Some(("X-AI".to_string(), "USD".to_string()))
        );
        assert_eq!(parse_crypto_pair_symbol("BTCUSD"), None);
        assert_eq!(parse_crypto_pair_symbol("BTC"), None);
    }

    #[test]
    fn test_parse_symbol_with_exchange_suffix() {
        let (symbol, mic) = parse_symbol_with_exchange_suffix("SHOP.TO");
        assert_eq!(symbol, "SHOP");
        assert_eq!(mic, Some("XTSE"));

        let (symbol, mic) = parse_symbol_with_exchange_suffix("VOD.L");
        assert_eq!(symbol, "VOD");
        assert_eq!(mic, Some("XLON"));

        let (symbol, mic) = parse_symbol_with_exchange_suffix("AAPL");
        assert_eq!(symbol, "AAPL");
        assert_eq!(mic, None);

        // Share class suffixes (not exchange suffixes) are preserved
        let (symbol, mic) = parse_symbol_with_exchange_suffix("BRK.B");
        assert_eq!(symbol, "BRK.B");
        assert_eq!(mic, None);
    }
}
